<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Лазорин Д.С., группа КС-21-04</title>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        .container {
            background: #141414;
            border-radius: 10px;
            padding: 40px;
            max-width: 900px;
            width: 100%;
            max-height: 95vh;
            overflow-y: auto;
            position: relative;
            z-index: 1;
            border: 1px solid #333;
        }

        .container::-webkit-scrollbar {
            width: 8px;
        }

        .container::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 10px;
        }

        .container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }


        .input-group {
            margin-bottom: 30px;
        }

        label {
            display: block;
            margin-bottom: 10px;
            color: #00ffff;
            font-size: 1.1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input {
            width: 100%;
            padding: 15px 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #ffffff;
            font-size: 1.2em;
            outline: none;
        }

        input:focus {
            border-color: #555;
            background: #1a1a1a;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        button {
            width: 100%;
            padding: 15px 30px;
            background: #00ffff;
            border: none;
            border-radius: 5px;
            color: #000;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }

        button:hover {
            background: #00cccc;
        }

        button:active {
            background: #009999;
        }

        button:disabled {
            background: rgba(100, 100, 100, 0.3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #docBtn {
            background: #4a7a9e;
            color: #ffffff;
        }

        #docBtn:hover {
            background: #3d6a8a;
        }

        #docBtn:active {
            background: #2f5570;
        }


        .results {
            margin-top: 30px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #333;
            display: none;
        }

        .results.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-item {
            margin-bottom: 15px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #333;
        }

        .result-label {
            color: #00ffff;
            font-weight: 600;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 1px;
        }

        .result-value {
            color: #ffffff;
            font-size: 1.5em;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #00ffff;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(0, 255, 255, 0.1);
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #1a1a1a;
            border: 1px solid #555;
            color: #ff6666;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            display: none;
        }

        .error.show {
            display: block;
        }


        .divider {
            height: 1px;
            background: #333;
            margin: 40px 0;
        }

        .section-title {
            text-align: left;
            color: #00ffff;
            font-size: 1.1em;
            margin-bottom: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .documentation-block {
            margin-top: 40px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #333;
        }

        .documentation-content {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #0f0f0f;
            border-radius: 5px;
            border: 1px solid #333;
            line-height: 1.8;
        }

        .documentation-content.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .documentation-content h3 {
            color: #00ffff;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .documentation-content h3:first-child {
            margin-top: 0;
        }

        .documentation-content p {
            color: #ffffff;
            margin-bottom: 15px;
            text-align: justify;
        }

        .documentation-content ul {
            color: #ffffff;
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .documentation-content li {
            margin-bottom: 8px;
        }

        .documentation-content code {
            background: #0a0a0a;
            padding: 2px 6px;
            border-radius: 3px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .documentation-content pre {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            overflow-x: auto;
            margin: 15px 0;
        }

        .documentation-content pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-group">
            <label for="blockNumber">Номер блока в БЛЧ Tron</label>
            <input 
                type="number" 
                id="blockNumber" 
                placeholder="Введите номер блока (например, 60000000)"
                min="0"
            >
        </div>

        <button id="searchBtn" onclick="searchBlock()">Найти блок</button>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Загрузка данных блока...</div>
        </div>

        <div class="error" id="error"></div>

        <div class="results" id="results">
            <div class="result-item">
                <div class="result-label">Количество транзакций</div>
                <div class="result-value" id="transactionCount">0</div>
            </div>
        </div>

        <button id="exportBtn" onclick="exportToExcel()" disabled>Выгрузить транзакции в Excel</button>

        <div class="divider"></div>


        <div class="input-group">
            <label for="txHash">Хэш транзакции</label>
            <input 
                type="text" 
                id="txHash" 
                placeholder="Введите хэш транзакции (например, a1b2c3d4...)"
            >
        </div>

        <button id="searchTxBtn" onclick="searchTransaction()">Найти транзакцию</button>

        <div class="loading" id="txLoading">
            <div class="spinner"></div>
            <div id="txLoadingText">Загрузка данных транзакции...</div>
        </div>

        <div class="error" id="txError"></div>

        <div class="results" id="txResults">
            <div class="result-item">
                <div class="result-label">tx_hour (Час суток)</div>
                <div class="result-value" id="txHour">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">is_contract_call (Вызов контракта)</div>
                <div class="result-value" id="isContractCall">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">bandwidth_usage (Потреблённый bandwidth)</div>
                <div class="result-value" id="bandwidthUsage">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">energy_usage</div>
                <div class="result-value" id="energyUsage">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">has_token_transfer</div>
                <div class="result-value" id="hasTokenTransfer">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">tx_size_bytes</div>
                <div class="result-value" id="txSizeBytes">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">result_success</div>
                <div class="result-value" id="resultSuccess">-</div>
            </div>
            <div class="result-item">
                <div class="result-label">paid_fee_s</div>
                <div class="result-value" id="paidFeeS">-</div>
            </div>
        </div>

        <button id="exportTxBtn" onclick="exportTransactionFeaturesToExcel()" disabled>Скачать Excel файл</button>

        <div class="divider"></div>

        <div>
            <button id="docBtn" onclick="toggleDocumentation()">Документация</button>
            <div class="documentation-content" id="documentationContent">
                <h3>Обзор проекта</h3>
                <p>
                    Данный сайт представляет собой веб-приложение для исследования блокчейна Tron (TRX). 
                    Он позволяет пользователям получать информацию о блоках и транзакциях в сети Tron, 
                    анализировать их структуру и экспортировать данные в Excel.
                </p>

                <h3>Технологический стек</h3>
                <p>Сайт реализован с использованием следующих технологий:</p>
                    <p>HTML5, CSS3, JavaSCript, TronGrid API, SheetJS.</p>
                <h3>Архитектура приложения</h3>
                <p>
                    Приложение построено как одностраничное веб-приложение (SPA) с клиентской логикой. 
                    Все вычисления и запросы к API выполняются непосредственно в браузере пользователя.
                </p>

                <h3>Основные функции</h3>
                
                <h3>1. Поиск блока по номеру</h3>
                <p>
                    Функция <code>searchBlock()</code> позволяет получить информацию о блоке по его номеру. 
                    Реализация включает валидацию введенного номера блока, асинхронный запрос к TronGrid API через endpoint <code>wallet/getblockbynum</code>, 
                    обработку ошибок сети и несуществующих блоков, отображение количества транзакций в блоке и сохранение данных транзакций для последующего экспорта. 
                    API запрос выполняется методом POST с телом запроса, содержащим номер блока. 
                    Ответ содержит полную информацию о блоке, включая все транзакции.
                </p>

                <h3>2. Экспорт транзакций в Excel</h3>
                <p>
                    Функция <code>exportToExcel()</code> использует библиотеку SheetJS для создания 
                    Excel файла с данными транзакций. Процесс включает преобразование массива транзакций в структурированные данные, 
                    извлечение ключевой информации: ID транзакции, номер блока, timestamp, тип контракта, 
                    создание рабочей книги Excel с настройкой ширины колонок и автоматическое скачивание файла с именем <code>tron_block_[номер]_transactions.xlsx</code>.
                </p>

                <h3>3. Поиск транзакции по хэшу</h3>
                <p>
                    Функция <code>searchTransaction()</code> реализует поиск транзакции по её хэшу. 
                    Особенности реализации: использование двух вариантов API для повышения надежности (v1 API: <code>/v1/transactions/{txHash}</code> 
                    и Wallet API: <code>/wallet/gettransactionbyid</code>), автоматический fallback на альтернативный API при ошибке первого 
                    и детальный анализ структуры транзакции.
                </p>

                <h3>4. Анализ транзакции</h3>
                <p>
                    Функция <code>analyzeTransaction()</code> выполняет глубокий анализ транзакции. 
                    <strong>Подсчет входов и выходов:</strong> Анализирует контракты транзакции, 
                    определяет адреса отправителей (owner_address) и получателей (to_address). 
                    Поддерживает различные типы контрактов: TransferContract, TransferAssetContract, 
                    TriggerSmartContract, MultiSignContract. 
                    <strong>Вычисление размера транзакции:</strong> Рассчитывает размер в байтах 
                    на основе сериализованного raw_data и подписей. Использует Blob API для точного 
                    измерения размера JSON данных. 
                    <strong>Расчет комиссии за байт:</strong> Извлекает комиссию из поля ret.fee, 
                    конвертирует из SUN в TRX (1 TRX = 1,000,000 SUN) и вычисляет комиссию на байт. 
                    <strong>Определение возраста входов:</strong> Находит самую старую входящую 
                    транзакцию для адресов-отправителей, что аналогично концепции UTXO в Bitcoin. 
                    Вычисляет время от момента получения средств до их траты.
                </p>

                <h3>5. Поиск истории транзакций адреса</h3>
                <p>
                    Функция <code>getOldestIncomingTransactionForAddress()</code> реализует сложный алгоритм 
                    поиска самой старой входящей транзакции. Использует пагинацию API для получения транзакций в хронологическом порядке, 
                    сортирует транзакции по возрастанию timestamp (order_by=block_timestamp,asc), 
                    проверяет каждую транзакцию на принадлежность к входящим через функцию <code>isIncomingTransaction()</code>, 
                    ограничивает поиск первыми 3 адресами из-за ограничений API и обрабатывает до 10 страниц результатов для повышения точности.
                </p>

                Функция <code>isIncomingTransaction()</code> определяет, является ли транзакция входящей для указанного адреса, поддерживая типы: TransferContract (переводы TRX), TransferAssetContract (переводы токенов), TriggerSmartContract (вызовы смарт-контрактов с возможными внутренними переводами), MultiSignContract (мультиподписные транзакции) и транзакции, содержащие множественные переводы через transfers array. Приложение использует публичный API TronGrid (<code>https://api.trongrid.io</code>) для доступа к данным блокчейна. Используемые endpoints: <code>POST /wallet/getblockbynum</code> (получение блока по номеру), <code>GET /v1/transactions/{txHash}</code> (получение транзакции через v1 API), <code>POST /wallet/gettransactionbyid</code> (получение транзакции через wallet API), <code>GET /v1/accounts/{address}/transactions</code> (получение транзакций адреса). Все запросы выполняются асинхронно с использованием <code>async/await</code>. 

                
            </div>
        </div>
    </div>

    <script>
        let currentTransactions = [];
        let currentBlockNumber = null;
        let currentTransaction = null;
        let currentTransactionFeatures = null;
        async function searchTransaction() {
            const txHash = document.getElementById('txHash').value.trim();
            if (!txHash) {
                showTxError('Пожалуйста, введите хэш транзакции');
                return;
            }
            const loading = document.getElementById('txLoading');
            const loadingText = document.getElementById('txLoadingText');
            const results = document.getElementById('txResults');
            const error = document.getElementById('txError');
            const searchBtn = document.getElementById('searchTxBtn');
            const exportTxBtn = document.getElementById('exportTxBtn');
            const blockResults = document.getElementById('results');
            const blockError = document.getElementById('error');
            results.classList.remove('show');
            error.classList.remove('show');
            blockResults.classList.remove('show');
            blockError.classList.remove('show');
            loading.classList.add('show');
            loadingText.textContent = 'Загрузка данных транзакции...';
            searchBtn.disabled = true;
            exportTxBtn.disabled = true;
            currentTransactionFeatures = null;
            try {
                let tx = null;
                try {
                    const response = await fetch('https://api.trongrid.io/wallet/gettransactionbyid', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            value: txHash
                        })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.txID || data.raw_data) {
                            tx = data;
                        }
                    }
                } catch (e) {
                    console.log('wallet API failed, trying v1 API');
                }
                if (!tx) {
                    try {
                        const response = await fetch(`https://api.trongrid.io/v1/transactions/${txHash}`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                            }
                        });
                        if (response.ok) {
                            const data = await response.json();
                            if (data.data && data.data.length > 0) {
                                tx = data.data[0];
                            }
                        } else if (response.status === 404) {
                            console.log('v1 API: транзакция не найдена (404)');
                        }
                    } catch (e) {
                        console.log('v1 API failed');
                    }
                }
                if (!tx) {
                    throw new Error('Транзакция не найдена. Проверьте правильность хэша.');
                }
                const txInfo = await fetchTransactionInfo(txHash);
                if (txInfo) {
                    tx.receipt = txInfo.receipt || tx.receipt || txInfo;
                    if (!tx.ret && txInfo.ret) {
                        tx.ret = txInfo.ret;
                    }
                    if (!tx.fee && txInfo.fee) {
                        tx.fee = txInfo.fee;
                    }
                    if (!tx.result && txInfo.result) {
                        tx.result = txInfo.result;
                    }
                    if (!tx.contractResult && txInfo.contractResult) {
                        tx.contractResult = txInfo.contractResult;
                    }
                    if (!tx.log && txInfo.log) {
                        tx.log = txInfo.log;
                    }
                }
                currentTransaction = tx;
                const loadingText = document.getElementById('txLoadingText');
                loadingText.textContent = 'Анализ транзакции и поиск истории входов...';
                await analyzeTransaction(tx);
                results.classList.add('show');
            } catch (err) {
                showTxError('Ошибка: ' + err.message + '. Проверьте правильность хэша транзакции.');
            } finally {
                loading.classList.remove('show');
                searchBtn.disabled = false;
            }
        }
        async function fetchTransactionInfo(txHash) {
            try {
                const resp = await fetch('https://api.trongrid.io/wallet/gettransactioninfobyid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ value: txHash })
                });
                if (!resp.ok) return null;
                return await resp.json();
            } catch (e) {
                console.error('fetchTransactionInfo failed', e);
                return null;
            }
        }
        async function analyzeTransaction(tx) {
            const rawData = tx.raw_data || {};
            const contracts = rawData.contract || [];
            const receipt = tx.receipt || {};
            const timestamp = rawData.timestamp || tx.block_timestamp || Date.now();
            const date = new Date(timestamp);
            const txHour = date.getUTCHours();
            let isContractCall = 0;
            for (const contract of contracts) {
                const contractType = contract.type || '';
                if (contractType === 'TriggerSmartContract' || contractType.includes('TriggerSmartContract')) {
                    isContractCall = 1;
                    break;
                }
            }
            let bandwidthUsage = 0;
            if (receipt.net_usage !== undefined && receipt.net_usage !== null) {
                bandwidthUsage = parseInt(receipt.net_usage) || 0;
            } else if (tx.net_usage !== undefined && tx.net_usage !== null) {
                bandwidthUsage = parseInt(tx.net_usage) || 0;
            }
            let energyUsage = 0;
            if (isContractCall === 1) {
                if (receipt.energy_usage_total !== undefined && receipt.energy_usage_total !== null) {
                    energyUsage = parseInt(receipt.energy_usage_total) || 0;
                } else if (receipt.energy_usage !== undefined && receipt.energy_usage !== null) {
                    energyUsage = parseInt(receipt.energy_usage) || 0;
                } else if (tx.energy_usage !== undefined && tx.energy_usage !== null) {
                    energyUsage = parseInt(tx.energy_usage) || 0;
                }
            }
            let hasTokenTransfer = 0;
            for (const contract of contracts) {
                const contractType = contract.type || '';
                const value = contract.parameter?.value || {};

                if (contractType === 'TransferAssetContract' || contractType.includes('TransferAsset')) {
                    hasTokenTransfer = 1;
                    break;
                }
                if (contractType === 'TriggerSmartContract' || contractType.includes('TriggerSmartContract')) {
                    if (tx.internal_transactions && Array.isArray(tx.internal_transactions)) {
                        for (const internalTx of tx.internal_transactions) {
                            if (internalTx.tokenInfo || internalTx.call_value === '0') {
                                hasTokenTransfer = 1;
                                break;
                            }
                        }
                    }
                    if (tx.log && Array.isArray(tx.log) && tx.log.length > 0) {
                        hasTokenTransfer = 1;
                    }
                    if (value.transfers && Array.isArray(value.transfers) && value.transfers.length > 0) {
                        hasTokenTransfer = 1;
                        break;
                    }
                }
                
                if (hasTokenTransfer === 1) break;
            }
            let txSizeBytes = 0;
            try {
                const rawDataSize = new Blob([JSON.stringify(rawData)]).size;
                const signaturesSize = tx.signature ? (Array.isArray(tx.signature) ? tx.signature.length * 128 : 128) : 0;
                txSizeBytes = rawDataSize + signaturesSize;
                if (txSizeBytes < 100) {
                    txSizeBytes = new Blob([JSON.stringify(tx)]).size;
                }
            } catch (e) {
                txSizeBytes = new Blob([JSON.stringify(tx)]).size;
            }
            let resultSuccess = 0;
            const ret = tx.ret || [];
            if (ret.length > 0) {
                const result = ret[0];
                if (result.contractRet === 'SUCCESS' || result.contractRet === 'success') {
                    resultSuccess = 1;
                } else if (result.result === 'SUCCESS' || result.result === 'success') {
                    resultSuccess = 1;
                }
            } else if (receipt.result === 'SUCCESS' || receipt.resMessage === 'SUCCESS' || tx.result === 'SUCCESS' || (Array.isArray(tx.contractResult) && tx.contractResult.some(r => r === 'SUCCESS'))) {
                resultSuccess = 1;
            }
            let paidFeeS = 0;
            if (receipt.fee !== undefined && receipt.fee !== null) {
                paidFeeS = parseInt(receipt.fee) || 0;
            } else if (tx.fee) {
                paidFeeS = parseInt(tx.fee) || 0;
            }
            if (paidFeeS === 0) {
                const netFee = receipt.net_fee ? parseInt(receipt.net_fee) || 0 : 0;
                const energyFee = receipt.energy_fee ? parseInt(receipt.energy_fee) || 0 : 0;
                paidFeeS = netFee + energyFee;
            }
            if (paidFeeS === 0 && ret.length > 0) {
                for (const r of ret) {
                    if (r.fee !== undefined && r.fee !== null) {
                        paidFeeS += parseInt(r.fee) || 0;
                    }
                }
            }
            currentTransactionFeatures = {
                tx_hour: txHour,
                bandwidth_usage: bandwidthUsage,
                energy_usage: energyUsage,
                tx_size_bytes: txSizeBytes,
                result_success: resultSuccess,
                paid_fee_s: paidFeeS,
                has_token_transfer: hasTokenTransfer
            };

            document.getElementById('txHour').textContent = txHour;
            document.getElementById('isContractCall').textContent = isContractCall;
            document.getElementById('bandwidthUsage').textContent = bandwidthUsage;
            document.getElementById('energyUsage').textContent = energyUsage;
            document.getElementById('hasTokenTransfer').textContent = hasTokenTransfer;
            document.getElementById('txSizeBytes').textContent = `${txSizeBytes} байт`;
            document.getElementById('resultSuccess').textContent = resultSuccess === 1 ? 'Успешно (1)' : 'Неуспешно (0)';
            document.getElementById('paidFeeS').textContent = `${paidFeeS} SUN`;

            document.getElementById('exportTxBtn').disabled = false;
        }

        function formatAgeInMinutes(ageMs) {
            const ageMinutes = Math.floor(ageMs / (1000 * 60));
            const ageHours = Math.floor(ageMinutes / 60);
            const ageDays = Math.floor(ageHours / 24);
            const ageWeeks = Math.floor(ageDays / 7);
            const ageMonths = Math.floor(ageDays / 30);
            const ageYears = Math.floor(ageDays / 365);
            
            if (ageYears > 0) {
                return `${ageMinutes} мин. (~${ageYears} ${ageYears === 1 ? 'год' : ageYears < 5 ? 'года' : 'лет'})`;
            } else if (ageMonths > 0) {
                return `${ageMinutes} мин. (~${ageMonths} ${ageMonths === 1 ? 'месяц' : ageMonths < 5 ? 'месяца' : 'месяцев'})`;
            } else if (ageWeeks > 0) {
                return `${ageMinutes} мин. (~${ageWeeks} ${ageWeeks === 1 ? 'неделя' : ageWeeks < 5 ? 'недели' : 'недель'})`;
            } else if (ageDays > 0) {
                return `${ageMinutes} мин. (${ageDays} ${ageDays === 1 ? 'день' : ageDays < 5 ? 'дня' : 'дней'})`;
            } else if (ageHours > 0) {
                return `${ageMinutes} мин. (${ageHours} ${ageHours === 1 ? 'час' : ageHours < 5 ? 'часа' : 'часов'})`;
            } else {
                return `${ageMinutes} ${ageMinutes === 1 ? 'минута' : ageMinutes < 5 ? 'минуты' : 'минут'}`;
            }
        }

        async function getOldestInputCreationTime(addresses, currentTimestamp, currentTxHash) {
            let oldestTimestamp = null;
            
            try {
                const addressesToCheck = addresses.slice(0, 3);
                const timestampPromises = [];
                
                for (const address of addressesToCheck) {
                    timestampPromises.push(
                        getOldestIncomingTransactionForAddress(address, currentTimestamp, currentTxHash)
                            .catch(() => null)
                    );
                }
                
                const timestamps = await Promise.all(timestampPromises);
                const validTimestamps = timestamps.filter(ts => ts !== null && ts < currentTimestamp);
                
                if (validTimestamps.length > 0) {
                    oldestTimestamp = Math.min(...validTimestamps);
                }
                
                return oldestTimestamp;
            } catch (err) {
                console.error('Error getting oldest input creation time:', err);
                return null;
            }
        }

        async function getOldestIncomingTransactionForAddress(address, maxTimestamp, excludeTxHash) {
            try {
                let oldestIncomingTx = null;
                let fingerprint = null;
                let page = 0;
                const maxPages = 10;
                
                while (page < maxPages) {
                    let url = `https://api.trongrid.io/v1/accounts/${address}/transactions?limit=200&order_by=block_timestamp,asc`;
                    if (fingerprint) {
                        url += `&fingerprint=${fingerprint}`;
                    }
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });

                    if (!response.ok) break;
                    
                    const data = await response.json();
                    if (!data.data || data.data.length === 0) break;
                    
                    for (const tx of data.data) {
                        const txHash = tx.txID || tx.transactionHash || '';
                        const txTimestamp = tx.block_timestamp || tx.raw_data?.timestamp || 0;
                        
                        if (txHash === excludeTxHash) continue;
                        if (txTimestamp >= maxTimestamp) {
                            return oldestIncomingTx ? (oldestIncomingTx.block_timestamp || oldestIncomingTx.raw_data?.timestamp) : null;
                        }
                        
                        if (isIncomingTransaction(tx, address)) {
                            if (!oldestIncomingTx || txTimestamp < (oldestIncomingTx.block_timestamp || oldestIncomingTx.raw_data?.timestamp || Infinity)) {
                                oldestIncomingTx = tx;
                            }
                        }
                    }
                    
                    if (oldestIncomingTx && page === 0) {
                        const oldestTs = oldestIncomingTx.block_timestamp || oldestIncomingTx.raw_data?.timestamp;
                      
                        return oldestTs;
                    }
                    
             
                    if (data.meta && data.meta.fingerprint) {
                        fingerprint = data.meta.fingerprint;
                        page++;
                    } else {
                        break;
                    }
                }
                
                return oldestIncomingTx ? (oldestIncomingTx.block_timestamp || oldestIncomingTx.raw_data?.timestamp) : null;
            } catch (err) {
                console.error(`Error fetching transactions for address ${address}:`, err);
                return null;
            }
        }

        function isIncomingTransaction(tx, address) {
            const contracts = tx.raw_data?.contract || [];
            
            for (const contract of contracts) {
                const contractType = contract.type || '';
                const value = contract.parameter?.value || {};
                
                if (contractType === 'TransferContract' || contractType.includes('Transfer')) {
                    if (value.to_address === address && value.owner_address !== address) {
                        return true;
                    }
                }
                
                if (contractType === 'TransferAssetContract' || contractType.includes('TransferAsset')) {
                    if (value.to_address === address && value.owner_address !== address) {
                        return true;
                    }
                }
                
                if (contractType === 'TriggerSmartContract') {
                    if (tx.internal_transactions) {
                        for (const internalTx of tx.internal_transactions) {
                            if (internalTx.to === address && internalTx.from !== address) {
                                return true;
                            }
                        }
                    }
                }
                
                if (contractType === 'MultiSignContract') {
                    if (value.addresses && Array.isArray(value.addresses) && value.addresses.includes(address)) {
                        return true;
                    }
                }
                
                if (value.transfers && Array.isArray(value.transfers)) {
                    if (value.transfers.some(t => t.to === address && t.from !== address)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function showTxError(message) {
            const error = document.getElementById('txError');
            error.textContent = message;
            error.classList.add('show');
        }

        async function searchBlock() {
            const blockNumber = document.getElementById('blockNumber').value;
            
            if (!blockNumber || blockNumber < 0) {
                showError('Пожалуйста, введите корректный номер блока');
                return;
            }

            currentBlockNumber = blockNumber;
            const loading = document.getElementById('loading');
            const results = document.getElementById('results');
            const error = document.getElementById('error');
            const exportBtn = document.getElementById('exportBtn');
            const searchBtn = document.getElementById('searchBtn');
            const txResults = document.getElementById('txResults');
            const txError = document.getElementById('txError');

            results.classList.remove('show');
            error.classList.remove('show');
            txResults.classList.remove('show');
            txError.classList.remove('show');
            loading.classList.add('show');
            searchBtn.disabled = true;
            exportBtn.disabled = true;

            try {
                const response = await fetch('https://api.trongrid.io/wallet/getblockbynum', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        num: parseInt(blockNumber)
                    })
                });

                if (!response.ok) {
                    throw new Error('Ошибка при получении данных блока');
                }

                const data = await response.json();

                if (data.Error) {
                    throw new Error(data.Error);
                }

                const transactions = data.transactions || [];
                currentTransactions = transactions;

                document.getElementById('transactionCount').textContent = transactions.length;
                results.classList.add('show');
                exportBtn.disabled = false;

            } catch (err) {
                showError('Ошибка: ' + err.message + '. Возможно, блок не существует или произошла ошибка сети.');
            } finally {
                loading.classList.remove('show');
                searchBtn.disabled = false;
            }
        }

        function showError(message) {
            const error = document.getElementById('error');
            error.textContent = message;
            error.classList.add('show');
        }

        function exportToExcel() {
            if (currentTransactions.length === 0) {
                showError('Нет транзакций для экспорта');
                return;
            }

            try {
                const excelData = currentTransactions.map((tx, index) => {
                    const txID = tx.txID || tx.transactionHash || 'N/A';
                    const blockNumber = currentBlockNumber;
                    const timestamp = tx.raw_data ? (tx.raw_data.timestamp || 'N/A') : 'N/A';
                    const contractType = tx.raw_data && tx.raw_data.contract && tx.raw_data.contract.length > 0 
                        ? (tx.raw_data.contract[0].type || 'N/A') 
                        : 'N/A';
                    
                    let contractInfo = 'N/A';
                    if (tx.raw_data && tx.raw_data.contract && tx.raw_data.contract.length > 0) {
                        const contract = tx.raw_data.contract[0];
                        if (contract.parameter && contract.parameter.value) {
                            contractInfo = JSON.stringify(contract.parameter.value);
                        }
                    }

                    return {
                        '№': index + 1,
                        'ID транзакции': txID,
                        'Номер блока': blockNumber,
                        'Время (timestamp)': timestamp,
                        'Тип контракта': contractType,
                        'Информация о контракте': contractInfo,
                        'Данные транзакции': JSON.stringify(tx)
                    };
                });

                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(excelData);

                const colWidths = [
                    { wch: 5 },  // №
                    { wch: 70 }, // ID транзакции
                    { wch: 15 }, // Номер блока
                    { wch: 20 }, // Время
                    { wch: 20 }, // Тип контракта
                    { wch: 50 }, // Информация о контракте
                    { wch: 100 } // Данные транзакции
                ];
                ws['!cols'] = colWidths;

                XLSX.utils.book_append_sheet(wb, ws, 'Транзакции');

                const fileName = `tron_block_${currentBlockNumber}_transactions.xlsx`;
                XLSX.writeFile(wb, fileName);

            } catch (err) {
                showError('Ошибка при экспорте в Excel: ' + err.message);
            }
        }

        document.getElementById('blockNumber').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchBlock();
            }
        });

        document.getElementById('txHash').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchTransaction();
            }
        });

        function exportTransactionFeaturesToExcel() {
            if (!currentTransactionFeatures) {
                showTxError('Нет данных для экспорта. Сначала найдите транзакцию.');
                return;
            }

            try {
      
                const excelData = [
                    {
                        'Признак': 'tx_hour',
                        'Значение': currentTransactionFeatures.tx_hour
                    },
                    {
                        'Признак': 'bandwidth_usage',
                        'Значение': currentTransactionFeatures.bandwidth_usage
                    },
                    {
                        'Признак': 'energy_usage',
                        'Значение': currentTransactionFeatures.energy_usage
                    },
                    {
                        'Признак': 'tx_size_bytes',
                        'Значение': currentTransactionFeatures.tx_size_bytes
                    },
                    {
                        'Признак': 'result_success',
                        'Значение': currentTransactionFeatures.result_success
                    },
                    {
                        'Признак': 'paid_fee_s',
                        'Значение': currentTransactionFeatures.paid_fee_s
                    },
                    {
                        'Признак': 'has_token_transfer',
                        'Значение': currentTransactionFeatures.has_token_transfer
                    }
                ];

                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(excelData);

                const colWidths = [
                    { wch: 25 },  // Признак
                    { wch: 15 }   // Значение
                ];
                ws['!cols'] = colWidths;

                XLSX.utils.book_append_sheet(wb, ws, 'Признаки транзакции');

                const txHash = document.getElementById('txHash').value.trim();
                const fileName = txHash ? `tron_tx_${txHash.substring(0, 16)}_features.xlsx` : 'tron_transaction_features.xlsx';
                XLSX.writeFile(wb, fileName);

            } catch (err) {
                showTxError('Ошибка при экспорте в Excel: ' + err.message);
            }
        }

        function toggleDocumentation() {
            const content = document.getElementById('documentationContent');
            const btn = document.getElementById('docBtn');
            
            if (content.classList.contains('show')) {
                content.classList.remove('show');
                btn.textContent = 'Документация';
            } else {
                content.classList.add('show');
                btn.textContent = 'Скрыть документацию';
            }
        }
    </script>
</body>
</html>

